---
title: Adding self-signed SSL certificates to Che
keywords:
tags: []
sidebar: che_7_docs
permalink: che-7/adding-self-signed-ssl-certificates-to-{prod-short}/
folder: che-7/installation-guide
summary:
---
:page-liquid:

[id="adding-self-signed-ssl-certificates-to-{prod-short}_{context}"]
= Adding self-signed SSL certificates to {prod-short}

When a {prod-short} user attempts to authenticate with {identity-provider} that is using OpenShift OAuth, the authentication fails if the {identity-provider} does not know the certificates needed for authorization.

To fix this problem, configure {prod-short} to authorize HTTPS communication with various components, such as identity and Git servers, by adding information about self-signed SSL certificates to a {prod-short} configuration.

.Prerequisites

* A Kubernetes orchestration tool, the OpenShift command-line tool, `oc`,
ifeval::["{project-context}" == "che"]
or the Kubernetes clusters controlling command-line tool, `kubectl`,
endif::[]
is installed.

.Procedure

. Save the desired self-signed certificates to a local file system.

. Create a new configMap that will contain the desired self-signed SSL certificates:
+
[subs="+attributes,+quotes"]
----
$ {orch-cli} create configmap __<configMap-name>__ --from-file=__<certificate-file-path>__ -n=__<che-namespace-name>__
----
+
To apply more than one certificate, add another `--from-file=_<certificate-file-path>_` option to the above command.

. Define a name for the newly created configMap.
+
NOTE: Use these steps with existing instances of {prod-short}. To install a new instance of {prod-short} with self-signed SSL certificates, create a new Che Custom Resource or Helm Chart property, based on the installation method selected, instead of updating the existing configuration.
+
====
** For a {prod-short} link:https://docs.openshift.com/container-platform/latest/operators/olm-what-operators-are.html[Operators] deployment :

* Define a name for the newly created configMap by editing the `spec.server.ServerTrustStoreConfigMapName` Che CustomResource property, to match the previously created configMap:
+
[subs="+attributes,+quotes",options="nowrap",role=white-space-pre]
----
$ {orch-cli} patch checluster eclipse-che -n che --type=json -p '[{"op": "replace", "path": "/spec/server/serverTrustStoreConfigMapName", "value": "__<config-map-name>__"}]'
----
====
+
ifeval::["{project-context}" == "che"]
====
** For a {prod-short} link:https://helm.sh/[Helm Chart] deployment: 
+
. Clone the https://github.com/eclipse/che[che] project
. Go to the `deploy/kubernetes/helm/che` directory
. Define a name for the newly created configMap by editing the `global.tls.serverTrustStoreConfigMapName` Helm Chart property, to match the previously created configMap:
+
[subs="+quotes",options="nowrap",role=white-space-pre]
----
$ helm upgrade che -n che --set global.tls.serverTrustStoreConfigMapName=<config-map name> --set global.ingressDomain=__<kubernetes-cluster-domain>__ .
----
+
Minikube users can obtain the _<kubernetes-cluster-domain>_ value by using `$(minikube ip).nip.io`.
====
endif::[]

.Verification 

If the certificates have been added correctly, the {prod-short} server starts and obtains {identity-provider} configuration over HTTPS with a self-signed SSL certificate, allowing user to:

* access the {prod-short} server
* log in using OpenShift OAuth
* clone over HTTPS from a Git repository that has a custom self-signed SSL  certificate
